### js中的原型与继承

--------

1. #### 继承的理解

   - ###### 继承是使得子类具有父类的各种属性和方法

   - ###### js中没有类的概念，所以继承是基于原型的继承
   
2. #### 实例对象的两种属性

   - ###### 实例属性：定义在构造方法中

   - ###### 原型属性：定义在原型方法中

   - ###### 可以使用hasOwnProperty进行区分

3. #### js继承的6种方式

   1. #####  原型链继承

      - ###### 令新实例的原型指向父类

        ```javascript
            // 定义一个父类 Hero
            function Hero(name){
                this.name = name//实例属性
                this.run = function(){
                    console.log('run fast')
                }
            }
        
            // 定义 fly height
            Hero.prototype.fly = function(){//原型属性
                console.log('i can fly')
            }
        
            Hero.prototype.height = '180cm'
        
            function Man(){
                this.name = 'man'
            }
        
            Man.prototype = new Hero()//令新实例的原型指向父类
        
            let newMan = new Man()
            newMan.run()//run fast
            console.log(newMan.height)// 180cm
        ```
        
       - ###### 优点：同名属性可覆盖，实例属性与原型属性皆可继承
      
    - ###### 缺点：新建实例无法像父类传参，所有实例共享父类属性
      
2. ##### 构造函数继承
   
   - ###### 通过构造函数.call() .apply() 讲父类构造函数 引入到 子类中
   
     ```javascript
        		// 定义一个父类 Hero
            function Hero(name){
                this.name = name;//实例属性
                this.run = function(){
                    console.log('run fast')
                }
            }
        
            // 定义 fly height
            Hero.prototype.fly = function(){//原型属性
                console.log('i can fly')
            }
        
            Hero.prototype.height = '180cm'
        
            function Man(){
                Hero.call(this,'funTwo')//传参 构造函数继承
                this.height = '185cm'
            }
        
            let newMan = new Man()
            console.log(newMan.name)    //funTwo
            console.log(newMan.height)  //185cm
            newMan.run()   							//run fast
            newMan.fly()   							//undefined 原型属性
        ```
   
      - ###### 优点：可以像父类传参，可以通过多次call（），继承多个父类属性
   
      - ###### 缺点：无法继承父类的原型属性
   
   3. ##### 组合继承（🌟）
   
      - ###### 原型链继承与构造函数继承的结合
   
        ```javascript
        		// 定义一个父类 Hero
            function Hero(name){
                this.name = name;//实例属性
                this.run = function(){
                    console.log('run fast')
                }
            }
        
            // 定义 fly height
            Hero.prototype.fly = function(){//原型属性
                console.log('i can fly')
            }
        
            Hero.prototype.height = '180cm'
        
            function Man(){
                Hero.call(this,'funTwo')	//1次
                this.height = '185cm'
            }
        
            Man.prototype = new Hero()		//2次
        
            let newMan = new Man()
            console.log(newMan.name)    //funTwo
            console.log(newMan.height)  //185cm
            newMan.run()                //run fast
            newMan.fly()                //i can fly
        ```
   
      - ###### 优点:结合前两种优点，可传参可复用，同时继承实例属性和原型属性，每个新实例通过构造函数引入的属性是私有的，互不影响
   
      - ###### 缺点：调用两次父类构造函数，消耗内存
   
   4. ##### 原型式继承
   
      - ###### 用函数包装一个对象，然后返回该函数的调用（object.create()通过该方法实现）
   
        ```javascript
        		// 定义一个父类 Hero
            function Hero(name){
                this.name = name;//实例属性
                this.run = function(){
                    console.log('run fast')
                }
            }
        
            // 定义 fly height
            Hero.prototype.fly = function(){//原型属性
                console.log('i can fly')
            }
        
            Hero.prototype.height = '180cm'
        
            function newFun(obj){       //该函数返回一个function，function的原型指向参数 obj，再返回该 obj
                function Fun(){
                    this.name = 'sss'
                }
                Fun.prototype = obj
                return new Fun()
            }
        
            let Man = new Hero()
        
            let curMan = newFun(Man)
            console.log(curMan.name)    //sss
            console.log(curMan.height)  //180cm
            curMan.run()                //run fast
            curMan.fly()                //i can fly
        ```
   
        
   
      - ###### 优点:
   
      - ###### 缺点:所有实例均继承原型属性，内存浪费。  实例属性无法复用
   
   5. ##### 寄生式继承
   
      - ###### 原型式继承的再次封装
   
        ```javascript
        		// 定义一个父类 Hero
            function Hero(name){
                this.name = name;//实例属性
                this.run = function(){
                    console.log('run fast')
                }
            }
        
            // 定义 fly height
            Hero.prototype.fly = function(){//原型属性
                console.log('i can fly')
            }
        
            Hero.prototype.height = '180cm'
        
            function newFun(obj){       //该函数返回一个function，function的原型指向参数 obj，再返回该 obj
                function Fun(){}
                Fun.prototype = obj
                return new Fun()
            }
        
            function newFun_(obj){			//寄生式继承
                let curObj = newFun(obj)
                curObj.name = 'abc'
                return curObj
            }
        
            let Man = new Hero()
        
            let curMan = newFun_(Man)
            console.log(curMan.name)    //abc
            console.log(curMan.height)  //180cm
            curMan.run()                //run fast
            curMan.fly()                //i can fly
        ```
   
      - ###### 优点：可自定义新实例的属性
   
      - ###### 缺点：新实例的属性没用到原型，无法复用
   
   6. ##### 寄生组合式继承（🌟）
   
      - ###### 寄生继承中传参直接传递 原型，
   
        ```javascript
        		// 定义一个父类 Hero
            function Hero(name){
                this.name = name;//实例属性
                this.run = function(){
                    console.log('run fast')
                }
            }
        
            // 定义 fly height
            Hero.prototype.fly = function(){//原型属性
                console.log('i can fly')
            }
        
            Hero.prototype.height = '180cm'
        
            function newFun(obj){       //该函数返回一个function，function的原型指向参数 obj，再返回该 obj
                function Fun(){}
                Fun.prototype = obj
                return new Fun()
            }
        
            // let Man = new Hero()
            // let curMan = newFun_(Man)
        
            //寄生
            let curMan = newFun(Hero.prototype)   //直接传递 父类原型
        
            //组合继承
            function newFun_(obj){
                Hero.call(this,'vvv')   //name参数，继承Hero构造函数属性，并且解决两次调用构造函数属性的缺点
            }
        
            newFun_.prototype = curMan      //继承实例
            curMan.constructor = newFun_    //修复实例
            let currentMan = new newFun_()  //currentMan实例 继承类 Hero的原型属性，
        
        
            
            console.log(currentMan.name)    //vvv
            console.log(currentMan.height)  //180cm
            currentMan.run()                //run fast
            currentMan.fly()                //i can fly
        ```
